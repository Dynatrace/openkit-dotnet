//
// Copyright 2018-2021 Dynatrace LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

using System;
using System.Collections.Generic;
using Dynatrace.OpenKit.Protocol;

namespace Dynatrace.OpenKit.Core.Caching
{
    /// <summary>
    /// Beacon Cache used to cache the Beacons generated by all sessions, actions, ...
    /// </summary>
    public interface IBeaconCache
    {
        /// <summary>
        /// Event raised, for each record added to the BeaconCache.
        /// </summary>
        /// <remarks>
        /// The <code>sender</code> is set to <code>this</code> and the event args is always <code>null</code>.
        /// </remarks>
        event EventHandler RecordAdded;

        /// <summary>
        /// Get a <code>HashSet</code> of currently inserted Beacon Keys.
        /// </summary>
        /// <remarks>
        /// The return value is a snapshot of currently inserted Beacon Keys.
        /// All changes made after this call are not reflected in the returned structure.
        /// </remarks>
        HashSet<BeaconKey> BeaconKeys { get; }

        /// <summary>
        /// Get number of bytes currently stored in cache.
        /// </summary>
        long NumBytesInCache { get; }

        /// <summary>
        /// Add event data for a given <paramref name="beaconKey"/> to this cache.
        /// </summary>
        /// <param name="beaconKey">The beacon's key (aka Session ID and Session seq. no.) for which to add event data.</param>
        /// <param name="timestamp">The data's timestamp.</param>
        /// <param name="data">Serialized event data to add.</param>
        void AddEventData(BeaconKey beaconKey, long timestamp, string data);

        /// <summary>
        /// Add action data for a given <paramref name="beaconKey"/> to this cache.
        /// </summary>
        /// <param name="beaconKey">The beacon's key (aka Session ID and Session seq. no.) for which to add event data.</param>
        /// <param name="timestamp">The data's timestamp.</param>
        /// <param name="data">Serialized event data to add.</param>
        void AddActionData(BeaconKey beaconKey, long timestamp, string data);

        /// <summary>
        /// Delete a cache entry for a given <paramref name="beaconKey"/>
        /// </summary>
        /// <param name="beaconKey">The beacon's key (aka Session ID and Session seq. no.) which to delete.</param>
        void DeleteCacheEntry(BeaconKey beaconKey);

        /// <summary>
        /// Get the next chunk for sending to the backend.
        /// </summary>
        /// <remarks>
        /// Note: This method must only be invoked from the beacon sending thread.
        /// </remarks>
        /// <param name="beaconKey">The beacon key for which to get the next chunk.</param>
        /// <param name="chunkPrefix">Prefix to append to the beginning of the chunk.</param>
        /// <param name="maxSize">Maximum chunk size. As soon as chunk's size >= maxSize result is returned.</param>
        /// <param name="delimiter">Delimiter between consecutive chunks.</param>
        /// <returns>
        /// <code>null</code> if given <code>beaconKey</code> does not exist, an empty string, if there is no more data to send
        /// or the next chunk to send.
        /// </returns>
        string GetNextBeaconChunk(BeaconKey beaconKey, string chunkPrefix, int maxSize, char delimiter);

        /// <summary>
        /// Remove all data that was previously included in chunks.
        /// </summary>
        /// <remarks>
        /// This method must be called, when data retrieved via <see cref="GetNextBeaconChunk(BeaconKey, string, int, char)"/> was
        /// successfully sent to the backend, otherwise subsequent calls to <see cref="GetNextBeaconChunk(BeaconKey, string, int, char)"/>
        /// will retrieve the same data again and again.
        ///
        /// Note: This method must only be invoked from the beacon sending thread.
        /// </remarks>
        /// <param name="beaconKey">The beacon key for which to remove already chunked data.</param>
        void RemoveChunkedData(BeaconKey beaconKey);

        /// <summary>
        /// Reset all data that was previously included in chunks.
        /// </summary>
        /// <remarks>
        /// Note: This method must only be invoked from the beacon sending thread.
        /// </remarks>
        /// <param name="beaconKey">The beacon key for which to remove already chunked data.</param>
        void ResetChunkedData(BeaconKey beaconKey);

        /// <summary>
        /// Evict <see cref="BeaconCacheRecord"/> by age for a given beacon.
        /// </summary>
        /// <param name="beaconKey">The key identifying a beacon.</param>
        /// <param name="minTimestamp">The minimum timestamp allowed.</param>
        /// <returns>The number of evicted cache records.</returns>
        int EvictRecordsByAge(BeaconKey beaconKey, long minTimestamp);

        /// <summary>
        /// Evict <see cref="BeaconCacheRecord"/> by number for given beacon.
        /// </summary>
        /// <param name="beaconKey">The key identifying a beacon.</param>
        /// <param name="numRecords"></param>
        /// <returns></returns>
        int EvictRecordsByNumber(BeaconKey beaconKey, int numRecords);

        /// <summary>
        /// Tests if an cached entry for <paramref name="beaconKey"/> is empty.
        /// </summary>
        /// <param name="beaconKey">The key identifying a beacon</param>
        /// <returns><code>true</code> if the cached entry is empty, <code>false</code> otherwise.</returns>
        bool IsEmpty(BeaconKey beaconKey);
    }
}
